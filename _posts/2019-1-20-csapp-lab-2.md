---
layout: post
title: "「CSAPP Lab」二进制炸弹实验"
subtitle: "Bomb Lab"
date: 2019-1-20
author: "ZingLix"
header-img: "img/post-36.jpg"
catalog: true
tags:
  - CSAPP-LAB
---

> Bomb Lab Version: 1/12/2016

二进制炸弹实验提供了一个可执行文件，要求用户输入 6 个密码才能够拆除炸弹，而密码并没有任何线索，所以只能够通过反汇编等方式确定。

```cpp
input = read_line();
phase_1(input);
phase_defused();
printf("Phase 1 defused. How about the next one?\n");

input = read_line();
phase_2(input);
phase_defused();
printf("That's number 2.  Keep going!\n");
```

其提供的主程序源代码十分清晰，每次密码通过 `read_line()` 获取，在 `phase_x` 中判断是否正确，`phase_defused()` 拆除炸弹，之后输出一条拆除成功的信息。所以说逆向的目标就是找出 `phase_x` 中到底是如何判断的。

## BOMB 1

先通过反汇编观察 `phase_1` 的源代码。

```
(gdb) disas phase_1
Dump of assembler code for function phase_1:
  0x0000000000400ee0 <+0>:   sub    $0x8,%rsp
  0x0000000000400ee4 <+4>:   mov    $0x402400,%esi
  0x0000000000400ee9 <+9>:   callq  0x401338 <strings_not_equal> ;判断字符串相等
  0x0000000000400eee <+14>:  test   %eax,%eax
  0x0000000000400ef0 <+16>:  je     0x400ef7 <phase_1+23>        ;相同则返回
  0x0000000000400ef2 <+18>:  callq  0x40143a <explode_bomb>      ;否则炸弹爆炸
  0x0000000000400ef7 <+23>:  add    $0x8,%rsp
  0x0000000000400efb <+27>:  retq
End of assembler dump.
```

通过函数名可以很清楚的了解到程序中做了些什么。如果你去观察 `strings_not_equal` 的汇编代码，可以看出他是先通过一个 `string_length` 判断两个字符串长度，不同则直接爆炸，否则再判断字符串相等。

```
(gdb) disas string_length
Dump of assembler code for function string_length:
   0x000000000040131b <+0>:     cmpb   $0x0,(%rdi)
   0x000000000040131e <+3>:     je     0x401332 <string_length+23>
   0x0000000000401320 <+5>:     mov    %rdi,%rdx
   0x0000000000401323 <+8>:     add    $0x1,%rdx
   0x0000000000401327 <+12>:    mov    %edx,%eax
   0x0000000000401329 <+14>:    sub    %edi,%eax
   0x000000000040132b <+16>:    cmpb   $0x0,(%rdx)
   0x000000000040132e <+19>:    jne    0x401323 <string_length+8>
   0x0000000000401330 <+21>:    repz retq
   0x0000000000401332 <+23>:    mov    $0x0,%eax
   0x0000000000401337 <+28>:    retq
End of assembler dump.
```

<+16> 就表示字符串以 0 结尾，那么回到 `phase_1` 中 `mov $0x402400, %esi`。这句话就表明了目标字符串所存储的位置。

```
(gdb) p (char*) 0x402400
$2 = 0x402400 "Border relations with Canada have never been better."
```

获得密码！

```
Border relations with Canada have never been better.
```

![](/img/in-post/CSAPP-Lab/2-1.png)

## BOMB 2

反汇编 `phase_2`。

```
(gdb) disas phase_2
Dump of assembler code for function phase_2:
   0x0000000000400efc <+0>:     push   %rbp
   0x0000000000400efd <+1>:     push   %rbx
   0x0000000000400efe <+2>:     sub    $0x28,%rsp
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi
   0x0000000000400f05 <+9>:     callq  0x40145c <read_six_numbers>
   0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp)
   0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>
   0x0000000000400f10 <+20>:    callq  0x40143a <explode_bomb>
   0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax
   0x0000000000400f1a <+30>:    add    %eax,%eax
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>
   0x0000000000400f20 <+36>:    callq  0x40143a <explode_bomb>
   0x0000000000400f25 <+41>:    add    $0x4,%rbx
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>
   0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx
   0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>
   0x0000000000400f3c <+64>:    add    $0x28,%rsp
   0x0000000000400f40 <+68>:    pop    %rbx
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    retq
End of assembler dump.
```

<+9> 这一行函数名 `read_six_numbers` 就表示了要读入 6 个数字。如果你去单部运行观察该函数内部，可以看到 esi 寄存器内容是 `%d %d %d %d %d %d`，可以印证这一猜想。

```
(gdb) p (char*) 0x4025c3
$1 = 0x4025c3 "%d %d %d %d %d %d"
```

随后 <+14> 判断是否为 1，之后进入一个循环，每次与 eax 比较，而每次 eax 都翻倍（<+30>）。因此这六个数字，第一个是 1，随后每次翻倍，就得到了密码。

```
1 2 4 8 16 32
```

![](/img/in-post/CSAPP-Lab/2-2.png)
